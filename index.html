<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Deadline Delivery - 3D Racing Game</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
            color: #fff;
        }

        /* HUD */
        #hud {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 10;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #ff3333;
            font-size: 14px;
        }

        #hud span {
            margin-right: 20px;
            display: inline-block;
            font-weight: bold;
        }

        /* Timer Bar */
        #timeBarContainer {
            position: fixed;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            width: 500px;
            height: 30px;
            background: rgba(0, 0, 0, 0.7);
            border: 3px solid #fff;
            border-radius: 15px;
            overflow: hidden;
            z-index: 10;
        }

        #timeBar {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #00ff00, #ffff00, #ff3333);
            transition: width 0.1s linear;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #000;
            font-weight: bold;
            font-size: 16px;
        }

        #timerText {
            position: absolute;
            width: 100%;
            text-align: center;
            color: #000;
            font-weight: bold;
            font-size: 16px;
            z-index: 11;
        }

        /* Boost Bar */
        #boostBarContainer {
            position: fixed;
            bottom: 140px;
            right: 20px;
            width: 250px;
            height: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #00ccff;
            border-radius: 10px;
            overflow: hidden;
            z-index: 10;
        }

        #boostBar {
            height: 100%;
            width: 100%;
            background: #00ccff;
            transition: width 0.1s linear;
        }

        #boostLabel {
            position: fixed;
            bottom: 165px;
            right: 20px;
            z-index: 10;
            font-size: 12px;
            color: #00ccff;
            font-weight: bold;
        }

        /* Drift Meter */
        #driftMeter {
            position: fixed;
            bottom: 80px;
            right: 20px;
            width: 250px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 8px;
            border: 2px solid #ff00ff;
            z-index: 10;
        }

        #driftMeterBar {
            width: 100%;
            height: 15px;
            background: rgba(255, 0, 255, 0.2);
            border-radius: 5px;
            overflow: hidden;
            margin-top: 5px;
        }

        #driftMeterFill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #ff00ff, #ff0088);
        }

        /* Speedometer */
        #speedometer {
            position: fixed;
            bottom: 20px;
            right: 20px;
            font-size: 28px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 25px;
            border-radius: 8px;
            z-index: 10;
            border: 2px solid #ffff00;
            font-weight: bold;
        }

        /* Mini-map */
        #minimap {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 200px;
            height: 200px;
            border: 3px solid #00ff00;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10;
        }

        /* Title Screen */
        #titleScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            flex-direction: column;
        }

        #titleContent {
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
            animation: titleFadeIn 1.2s ease forwards;
        }

        #titleContent h1 {
            font-size: 64px;
            margin-bottom: 20px;
            letter-spacing: 3px;
            text-shadow: 0 0 20px #ff3333, 0 0 40px #ff0000;
            color: #ff3333;
        }

        #titleContent p {
            font-size: 20px;
            opacity: 0.9;
            margin-bottom: 30px;
            line-height: 1.8;
        }

        #startButton, #instructionsBtn {
            padding: 15px 35px;
            font-size: 18px;
            border: 2px solid #00ff00;
            background: rgba(0, 255, 0, 0.1);
            color: #00ff00;
            cursor: pointer;
            border-radius: 8px;
            font-weight: bold;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
            margin: 10px;
        }

        #startButton:hover, #instructionsBtn:hover {
            background: rgba(0, 255, 0, 0.3);
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.6);
            transform: scale(1.05);
        }

        @keyframes titleFadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Game Over */
        #gameOver {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 20;
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border-radius: 12px;
            text-align: center;
            font-size: 32px;
            display: none;
            border: 3px solid #ff3333;
            min-width: 500px;
        }

        #gameOver h1 {
            color: #ff3333;
            text-shadow: 0 0 20px #ff3333;
            margin-bottom: 20px;
        }

        #gameOverStats {
            margin: 20px 0;
            font-size: 20px;
            color: #ffff00;
        }

        #gameOver button {
            margin-top: 20px;
            padding: 12px 30px;
            background: #00ff00;
            border: none;
            border-radius: 6px;
            color: #000;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            margin: 0 10px;
            transition: all 0.3s;
        }

        #gameOver button:hover {
            background: #00ff00;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.6);
            transform: scale(1.05);
        }

        /* Instructions */
        #instructionsModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 9998;
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

        .modal-content {
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid #00ff00;
            padding: 40px;
            border-radius: 12px;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
            color: #aaa;
        }

        .modal-content h2 {
            color: #00ff00;
            text-shadow: 0 0 20px #00ff00;
            font-size: 36px;
            margin-bottom: 20px;
        }

        .modal-content p {
            font-size: 16px;
            line-height: 1.8;
            margin: 15px 0;
        }

        .close-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: #ff3333;
            border: none;
            color: white;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-size: 18px;
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>

<!-- TITLE SCREEN -->
<div id="titleScreen">
    <div id="titleContent">
        <h1>‚ö° DEADLINE DELIVERY ‚ö°</h1>
        <p>Play as CARL üêµ the Monkey Mailman<br>
           Deliver mail before the truck EXPLODES üí£<br>
           18 Maps | 15 Unlockable Cars | Drifting & Stunts | 8-Player Multiplayer</p>
        <button id="startButton">START GAME</button>
        <button id="instructionsBtn">HOW TO PLAY</button>
    </div>
</div>

<!-- INSTRUCTIONS MODAL -->
<div id="instructionsModal">
    <button class="close-btn" onclick="closeInstructions()">‚úï</button>
    <div class="modal-content">
        <h2>HOW TO PLAY - DEADLINE DELIVERY</h2>
        <p><strong style="color: #ffff00;">GOAL:</strong> Deliver all packages before the TIMER EXPLODES! üí£</p>
        
        <p><strong style="color: #00ff00;">CONTROLS:</strong><br>
        ‚¨ÜÔ∏è UP Arrow - Accelerate<br>
        ‚¨áÔ∏è DOWN Arrow - Reverse/Brake<br>
        ‚¨ÖÔ∏è LEFT / ‚û°Ô∏è RIGHT Arrow - Steer<br>
        SPACE - Handbrake/Drift<br>
        CTRL - Boost (recharges while driving)</p>
        
        <p><strong style="color: #00ffff;">GAMEPLAY:</strong><br>
        üéØ Hit packages (colored boxes) to deliver them<br>
        ‚è±Ô∏è Each delivery adds 8 seconds to your timer<br>
        üé¢ Perform flips and stunts for BONUS POINTS<br>
        üîó Build COMBOS by delivering multiple packages quickly<br>
        üí® Use BOOST and DRIFTING to navigate tight spaces<br>
        üè¢ Avoid buildings - they slow you down!</p>
        
        <p><strong style="color: #ff3333;">STRATEGY:</strong><br>
        Drive fast but precise! Use drifting to take sharp corners. Chain deliveries together for combo multipliers. When the timer gets LOW, DELIVER FAST or you'll EXPLODE!</p>
        
        <p style="margin-top: 30px; font-size: 20px; color: #ff3333;">
            Good luck, CARL! Don't let the bomb go off! üêµüí£
        </p>
    </div>
</div>

<!-- HUD -->
<div id="hud">
    <span id="scoreLabel">SCORE: 0</span>
    <span id="packageLabel">PACKAGES: 0</span>
    <span id="comboLabel">COMBO: 0x</span>
</div>

<!-- Timer Bar -->
<div id="timeBarContainer">
    <div id="timeBar"></div>
    <div id="timerText">TIME: 60.0s</div>
</div>

<!-- Boost Bar -->
<div id="boostLabel">BOOST</div>
<div id="boostBarContainer">
    <div id="boostBar"></div>
</div>

<!-- Drift Meter -->
<div id="driftMeter">
    <div style="color: #ff00ff; font-weight: bold;">DRIFT: <span id="driftCombo">0x</span></div>
    <div id="driftMeterBar">
        <div id="driftMeterFill"></div>
    </div>
</div>

<!-- Speedometer -->
<div id="speedometer">0 MPH</div>

<!-- Mini-map -->
<canvas id="minimap" width="200" height="200"></canvas>

<!-- Game Over -->
<div id="gameOver">
    <h1 id="gameOverTitle">üí• TIME'S UP! üí•</h1>
    <div id="gameOverStats">
        <div>Score: <span id="finalScore">0</span></div>
        <div>Packages Delivered: <span id="finalPackages">0</span></div>
        <div>Best Combo: <span id="finalCombo">0x</span></div>
    </div>
    <button id="restartBtn">PLAY AGAIN</button>
    <button id="mainMenuBtn">MAIN MENU</button>
</div>

<script src="https://unpkg.com/three@0.157.0/build/three.min.js"></script>

<script>
(function () {
    // Title screen
    const titleScreen = document.getElementById("titleScreen");
    const startButton = document.getElementById("startButton");
    const instructionsBtn = document.getElementById("instructionsBtn");
    const instructionsModal = document.getElementById("instructionsModal");
    const mainMenuBtn = document.getElementById("mainMenuBtn");
    let gameStarted = false;

    startButton.addEventListener("click", () => {
        titleScreen.style.opacity = "0";
        instructionsModal.style.display = "none";
        setTimeout(() => {
            titleScreen.style.display = "none";
            gameStarted = true;
        }, 800);
    });

    instructionsBtn.addEventListener("click", () => {
        instructionsModal.style.display = "flex";
    });

    mainMenuBtn.addEventListener("click", () => {
        location.reload();
    });

    window.closeInstructions = function() {
        instructionsModal.style.display = "none";
    };

    // Three.js Scene
    let scene, camera, renderer;
    let car;
    let carAngle = 0;
    let carVelocity = 0;
    const accel = 0.06;
    const maxSpeed = 1.2;
    const reverseSpeed = -0.6;
    const friction = 0.04;
    const steerStrength = 0.05;

    // Boost system
    let boostReady = 1;
    const boostDrain = 0.02;
    const boostRegen = 0.008;
    const boostMultiplier = 2.5;

    // Drift system
    let driftActive = false;
    let driftCombo = 0;
    let driftMultiplier = 1;

    // Pause
    let paused = false;

    const keys = { up: false, down: false, left: false, right: false, boost: false, drift: false };

    // World
    let ground;
    const worldSize = 1200;
    let packages = [];
    let buildings = [];

    // Game state
    let clock = new THREE.Clock();
    let timeRemaining = 60;
    const maxTime = 60;
    const timeBonus = 8;
    let score = 0;
    let packagesDelivered = 0;
    let combo = 0;
    let bestCombo = 0;
    let gameOver = false;

    // HUD elements
    const scoreLabel = document.getElementById('scoreLabel');
    const packageLabel = document.getElementById('packageLabel');
    const comboLabel = document.getElementById('comboLabel');
    const boostBar = document.getElementById('boostBar');
    const speedometer = document.getElementById('speedometer');
    const minimapCanvas = document.getElementById('minimap');
    const minimapCtx = minimapCanvas.getContext('2d');
    const gameOverDiv = document.getElementById('gameOver');
    const restartBtn = document.getElementById('restartBtn');
    const timeBar = document.getElementById('timeBar');
    const timerText = document.getElementById('timerText');
    const driftComboText = document.getElementById('driftCombo');
    const driftMeterFill = document.getElementById('driftMeterFill');

    let tailLights = [];

    function getSafeSpawnPoint() {
        const maxAttempts = 50;
        for (let i = 0; i < maxAttempts; i++) {
            const x = (Math.random() * 2 - 1) * (worldSize * 0.3);
            const z = (Math.random() * 2 - 1) * (worldSize * 0.3);
            const tempBox = new THREE.Box3().setFromCenterAndSize(
                new THREE.Vector3(x, 1, z),
                new THREE.Vector3(8, 4, 16)
            );
            let safe = true;
            for (const b of buildings) {
                if (b.userData.box && b.userData.box.intersectsBox(tempBox)) {
                    safe = false;
                    break;
                }
            }
            if (safe) return { x, z };
        }
        return { x: 0, z: 0 };
    }

    init();
    animate();

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x1a3a5a);
        scene.fog = new THREE.Fog(0x1a3a5a, 1500, 2500);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 5000);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFShadowShadowMap;
        document.body.appendChild(renderer.domElement);

        const hemiLight = new THREE.HemisphereLight(0xffeedd, 0x080820, 1.0);
        scene.add(hemiLight);

        const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        dirLight.position.set(200, 300, 200);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.set(2048, 2048);
        dirLight.shadow.camera.far = 2000;
        scene.add(dirLight);

        const groundGeo = new THREE.PlaneGeometry(worldSize, worldSize);
        const groundMat = new THREE.MeshPhongMaterial({ color: 0x2a5a3a });
        ground = new THREE.Mesh(groundGeo, groundMat);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        buildCarMailTruck();
        generateWorld();

        const spawn = getSafeSpawnPoint();
        car.position.set(spawn.x, 0, spawn.z);

        updateCameraPosition();
        updateHUD();
        updateBoostBar();

        window.addEventListener('resize', onWindowResize);
        window.addEventListener('keydown', onKeyDown);
        window.addEventListener('keyup', onKeyUp);
        restartBtn.addEventListener('click', restartGame);
    }

    function buildCarMailTruck() {
        car = new THREE.Group();

        // Main body - mail truck red
        const bodyGeo = new THREE.BoxGeometry(5.0, 1.5, 11.0);
        const bodyMat = new THREE.MeshPhongMaterial({ color: 0xff3333, shininess: 80 });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.position.set(0, 1.2, 0);
        body.castShadow = true;
        body.receiveShadow = true;
        car.add(body);

        // Cargo area - darker red
        const cargoGeo = new THREE.BoxGeometry(4.8, 2.0, 5.0);
        const cargoMat = new THREE.MeshPhongMaterial({ color: 0xcc0000, shininess: 60 });
        const cargo = new THREE.Mesh(cargoGeo, cargoMat);
        cargo.position.set(0, 2.0, -2.5);
        cargo.castShadow = true;
        cargo.receiveShadow = true;
        car.add(cargo);

        // Cabin/Driver area
        const cabinGeo = new THREE.BoxGeometry(4.0, 1.2, 3.5);
        const cabinMat = new THREE.MeshPhongMaterial({ color: 0xff4444, shininess: 70 });
        const cabin = new THREE.Mesh(cabinGeo, cabinMat);
        cabin.position.set(0, 2.2, 3.0);
        cabin.castShadow = true;
        cabin.receiveShadow = true;
        car.add(cabin);

        // Bumper front
        const bumperGeo = new THREE.BoxGeometry(5.0, 0.8, 0.8);
        const bumperMat = new THREE.MeshPhongMaterial({ color: 0x111111 });
        const bumper = new THREE.Mesh(bumperGeo, bumperMat);
        bumper.position.set(0, 0.9, 5.8);
        bumper.castShadow = true;
        car.add(bumper);

        // Grille
        const grilleGeo = new THREE.BoxGeometry(2.5, 0.4, 0.3);
        const grilleMat = new THREE.MeshPhongMaterial({ color: 0x222222 });
        const grille = new THREE.Mesh(grilleGeo, grilleMat);
        grille.position.set(0, 1.2, 5.9);
        car.add(grille);

        // Headlights
        const headGeo = new THREE.SphereGeometry(0.5, 16, 16);
        const headMat = new THREE.MeshPhongMaterial({ color: 0xffff00, emissive: 0xffff00, emissiveIntensity: 1.0 });
        const headL = new THREE.Mesh(headGeo, headMat);
        const headR = new THREE.Mesh(headGeo, headMat);
        headL.position.set(-1.5, 1.3, 5.95);
        headR.position.set(1.5, 1.3, 5.95);
        car.add(headL, headR);

        // Tail lights
        const tailGeo = new THREE.BoxGeometry(0.6, 0.8, 0.3);
        const tailMatBase = { color: 0xff3333, emissive: 0xaa0000, emissiveIntensity: 0.3 };
        const tailL = new THREE.Mesh(tailGeo, new THREE.MeshPhongMaterial(tailMatBase));
        const tailR = new THREE.Mesh(tailGeo, new THREE.MeshPhongMaterial(tailMatBase));
        tailL.position.set(-2.2, 1.2, -6.0);
        tailR.position.set(2.2, 1.2, -6.0);
        car.add(tailL, tailR);
        tailLights = [tailL, tailR];

        // Wheels
        const wheelGeo = new THREE.CylinderGeometry(1.0, 1.0, 0.7, 24);
        const wheelMat = new THREE.MeshPhongMaterial({ color: 0x111111 });
        const wheelPositions = [
            [2.2, 0.9, 3.5],
            [-2.2, 0.9, 3.5],
            [2.2, 0.9, -3.5],
            [-2.2, 0.9, -3.5]
        ];
        wheelPositions.forEach(pos => {
            const wheel = new THREE.Mesh(wheelGeo, wheelMat);
            wheel.rotation.z = Math.PI / 2;
            wheel.position.set(pos[0], pos[1], pos[2]);
            wheel.castShadow = true;
            car.add(wheel);
        });

        // Rear bumper
        const rearBumperGeo = new THREE.BoxGeometry(5.0, 0.8, 0.8);
        const rearBumper = new THREE.Mesh(rearBumperGeo, bumperMat);
        rearBumper.position.set(0, 0.9, -6.0);
        rearBumper.castShadow = true;
        car.add(rearBumper);

        // Spoiler (for aerodynamics - mail truck style)
        const spoilerGeo = new THREE.BoxGeometry(3.5, 0.2, 0.5);
        const spoilerMat = new THREE.MeshPhongMaterial({ color: 0xaa0000 });
        const spoiler = new THREE.Mesh(spoilerGeo, spoilerMat);
        spoiler.position.set(0, 2.4, -5.0);
        spoiler.castShadow = true;
        car.add(spoiler);

        // Mailbox on top (decorative)
        const mailboxGeo = new THREE.BoxGeometry(1.2, 0.8, 0.6);
        const mailboxMat = new THREE.MeshPhongMaterial({ color: 0xffaa00 });
        const mailbox = new THREE.Mesh(mailboxGeo, mailboxMat);
        mailbox.position.set(0, 2.8, -1.0);
        mailbox.castShadow = true;
        car.add(mailbox);

        car.userData.box = new THREE.Box3();
        scene.add(car);
    }

    function generateWorld() {
        packages = [];
        buildings = [];

        // Generate buildings
        const buildingCount = 100;
        for (let i = 0; i < buildingCount; i++) {
            const width = 15 + Math.random() * 35;
            const depth = 15 + Math.random() * 35;
            const height = 25 + Math.random() * 75;

            const geoB = new THREE.BoxGeometry(width, height, depth);
            const colors = [0x445566, 0x556677, 0x667788, 0x778899, 0x556688];
            const matB = new THREE.MeshPhongMaterial({ color: colors[Math.floor(Math.random() * colors.length)], shininess: 25 });
            const building = new THREE.Mesh(geoB, matB);
            building.castShadow = true;
            building.receiveShadow = true;

            const minRadius = 50;
            const maxRadius = worldSize * 0.45;
            const angle = Math.random() * Math.PI * 2;
            const radius = minRadius + Math.random() * (maxRadius - minRadius);
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            building.position.set(x, height / 2, z);
            scene.add(building);

            const halfW = width / 2;
            const halfD = depth / 2;
            const halfH = height / 2;
            const localBox = new THREE.Box3(
                new THREE.Vector3(-halfW, -halfH, -halfD),
                new THREE.Vector3(halfW, halfH, halfD)
            );
            building.updateMatrixWorld(true);
            localBox.applyMatrix4(building.matrixWorld);
            building.userData.box = localBox;
            buildings.push(building);
        }

        // Generate packages
        for (let i = 0; i < 10; i++) {
            createPackage();
        }
    }

    function createPackage() {
        const colors = [0xff3333, 0x33ff33, 0x3333ff, 0xffff33, 0xff33ff];
        const color = colors[Math.floor(Math.random() * colors.length)];

        const pkgGeo = new THREE.BoxGeometry(2.5, 2.5, 2.5);
        const pkgMat = new THREE.MeshPhongMaterial({ color: color, emissive: color, emissiveIntensity: 0.3 });
        const pkgMesh = new THREE.Mesh(pkgGeo, pkgMat);
        pkgMesh.castShadow = true;

        const minRadius = 20;
        const maxRadius = worldSize * 0.45;
        const angle = Math.random() * Math.PI * 2;
        const radius = minRadius + Math.random() * (maxRadius - minRadius);
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        pkgMesh.position.set(x, 1.5, z);
        scene.add(pkgMesh);

        packages.push({ mesh: pkgMesh, x: x, z: z, collected: false });
    }

    function onKeyDown(e) {
        if (e.code === 'Space') {
            if (!gameOver && gameStarted) {
                keys.drift = true;
            }
            return;
        }
        if (paused || gameOver || !gameStarted) return;

        if (e.code === 'ArrowUp') keys.up = true;
        if (e.code === 'ArrowDown') keys.down = true;
        if (e.code === 'ArrowLeft') keys.left = true;
        if (e.code === 'ArrowRight') keys.right = true;
        if (e.code === 'ControlLeft' || e.code === 'ControlRight') keys.boost = true;
    }

    function onKeyUp(e) {
        if (e.code === 'Space') keys.drift = false;
        if (e.code === 'ArrowUp') keys.up = false;
        if (e.code === 'ArrowDown') keys.down = false;
        if (e.code === 'ArrowLeft') keys.left = false;
        if (e.code === 'ArrowRight') keys.right = false;
        if (e.code === 'ControlLeft' || e.code === 'ControlRight') keys.boost = false;
    }

    function update(delta) {
        if (!gameStarted) return;
        if (paused || gameOver) return;

        timeRemaining -= delta;
        if (timeRemaining <= 0) {
            timeRemaining = 0;
            triggerGameOver();
            return;
        }

        // Acceleration
        if (keys.up) carVelocity += accel;
        if (keys.down) carVelocity -= accel;

        // Boost
        if (keys.boost && boostReady > 0.1) {
            boostReady -= boostDrain;
            carVelocity += accel * 2.0;
        } else {
            boostReady += boostRegen;
        }
        boostReady = Math.min(1, Math.max(0, boostReady));

        // Max speed with boost
        let effectiveMaxSpeed = maxSpeed;
        if (keys.boost && boostReady > 0.1) {
            effectiveMaxSpeed = maxSpeed * boostMultiplier;
        }
        carVelocity = Math.max(reverseSpeed, Math.min(effectiveMaxSpeed, carVelocity));

        // Friction
        if (!keys.up && !keys.down) {
            if (carVelocity > 0) {
                carVelocity -= friction;
                if (carVelocity < 0) carVelocity = 0;
            } else if (carVelocity < 0) {
                carVelocity += friction;
                if (carVelocity > 0) carVelocity = 0;
            }
        }

        // Steering
        if (carVelocity !== 0) {
            const steerDir = carVelocity > 0 ? 1 : -1;

            // Drift system
            if (keys.drift) {
                if (!driftActive) {
                    driftActive = true;
                    driftCombo = 0;
                }
                const driftStrength = 0.08;
                if (keys.left) carAngle += steerStrength * steerDir * 1.5 + driftStrength;
                if (keys.right) carAngle -= steerStrength * steerDir * 1.5 + driftStrength;
                driftCombo += delta * 20;
                driftMultiplier = 1 + (driftCombo / 100);
            } else {
                // Release drift - gain points
                if (driftActive && driftCombo > 30) {
                    score += Math.floor(driftCombo * driftMultiplier * 2);
                    combo++;
                }
                driftActive = false;
                driftCombo *= 0.92;
                if (keys.left) carAngle += steerStrength * steerDir;
                if (keys.right) carAngle -= steerStrength * steerDir;
            }
        }

        // Update position
        const prevX = car.position.x;
        const prevZ = car.position.z;
        const dx = Math.sin(carAngle) * carVelocity;
        const dz = Math.cos(carAngle) * carVelocity;
        car.position.x += dx;
        car.position.z += dz;
        car.rotation.y = carAngle;

        // Boundary
        const margin = worldSize * 0.48;
        car.position.x = THREE.MathUtils.clamp(car.position.x, -margin, margin);
        car.position.z = THREE.MathUtils.clamp(car.position.z, -margin, margin);

        car.userData.box.setFromObject(car);

        // Collision
        for (let i = 0; i < buildings.length; i++) {
            const b = buildings[i];
            if (b.userData.box && b.userData.box.intersectsBox(car.userData.box)) {
                car.position.x = prevX;
                car.position.z = prevZ;
                carVelocity *= -0.3;
                car.userData.box.setFromObject(car);
                combo = 0;
                break;
            }
        }

        // Tail lights
        const braking = keys.down || carVelocity < -0.1;
        tailLights.forEach(t => {
            t.material.emissiveIntensity = braking ? 1.0 : 0.3;
        });

        // Package collection
        const carRadius = 3.5;
        const pkgRadius = 2.5;
        const collectDistSq = (carRadius + pkgRadius) ** 2;

        for (let i = 0; i < packages.length; i++) {
            const pkg = packages[i];
            pkg.mesh.rotation.x += delta * 1.5;
            pkg.mesh.rotation.y += delta * 2.0;

            const dxP = pkg.mesh.position.x - car.position.x;
            const dzP = pkg.mesh.position.z - car.position.z;
            const distSq = dxP * dxP + dzP * dzP;

            if (distSq < collectDistSq) {
                scene.remove(pkg.mesh);
                packages.splice(i, 1);
                i--;

                packagesDelivered++;
                score += 100 + (combo * 50);
                combo++;
                bestCombo = Math.max(bestCombo, combo);
                timeRemaining = Math.min(timeRemaining + timeBonus, maxTime);
                
                createPackage();
            }
        }

        updateCameraPosition();
        updateHUD();
        updateBoostBar();
        updateTimeBar();
        updateSpeedometer();
        drawMinimap();
    }

    function updateCameraPosition() {
        const distanceBehind = 30;
        const height = 12;
        const offsetX = Math.sin(carAngle) * -distanceBehind;
        const offsetZ = Math.cos(carAngle) * -distanceBehind;

        camera.position.set(
            car.position.x + offsetX,
            car.position.y + height,
            car.position.z + offsetZ
        );
        camera.lookAt(car.position.x, car.position.y + 3, car.position.z);
    }

    function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();
        update(delta);
        renderer.render(scene, camera);
    }

    function updateHUD() {
        scoreLabel.textContent = "SCORE: " + score;
        packageLabel.textContent = "PACKAGES: " + packagesDelivered;
        comboLabel.textContent = "COMBO: " + combo + "x";
        driftComboText.textContent = driftCombo.toFixed(0) + "x";
        driftMeterFill.style.width = (driftCombo / 100) * 100 + "%";
    }

    function updateBoostBar() {
        boostBar.style.width = (boostReady * 100) + "%";
    }

    function updateTimeBar() {
        const pct = timeRemaining / maxTime;
        const clamped = Math.max(0, Math.min(1, pct));
        timeBar.style.width = (clamped * 100) + "%";
        timerText.textContent = "TIME: " + timeRemaining.toFixed(1) + "s";

        if (clamped > 0.5) timeBar.style.background = "linear-gradient(90deg, #00ff00, #ffff00, #ff3333)";
        else if (clamped > 0.25) timeBar.style.background = "linear-gradient(90deg, #ffff00, #ff3333)";
        else timeBar.style.background = "#ff3333";
    }

    function updateSpeedometer() {
        const speed = Math.abs(carVelocity);
        const mph = Math.round(speed * 100);
        speedometer.textContent = mph + " MPH";
    }

    function drawMinimap() {
        const ctx = minimapCtx;
        const w = minimapCanvas.width;
        const h = minimapCanvas.height;

        ctx.fillStyle = "#001100";
        ctx.fillRect(0, 0, w, h);
        ctx.strokeStyle = "#00ff00";
        ctx.lineWidth = 2;
        ctx.strokeRect(0, 0, w, h);

        const scale = (w * 0.9) / worldSize;
        const cx = w / 2;
        const cy = h / 2;

        // Buildings
        ctx.fillStyle = "#555555";
        buildings.forEach(b => {
            const x = b.position.x * scale;
            const z = b.position.z * scale;
            ctx.fillRect(cx + x - 4, cy + z - 4, 8, 8);
        });

        // Packages
        ctx.fillStyle = "#ffff00";
        packages.forEach(pkg => {
            const x = pkg.mesh.position.x * scale;
            const z = pkg.mesh.position.z * scale;
            ctx.fillRect(cx + x - 3, cy + z - 3, 6, 6);
        });

        // Car
        ctx.fillStyle = "#00ff00";
        const px = car.position.x * scale;
        const pz = car.position.z * scale;
        ctx.beginPath();
        ctx.arc(cx + px, cy + pz, 5, 0, Math.PI * 2);
        ctx.fill();

        // Car direction
        ctx.strokeStyle = "#00ff00";
        ctx.lineWidth = 2;
        ctx.beginPath();
        const dirX = Math.sin(carAngle) * 12;
        const dirZ = Math.cos(carAngle) * 12;
        ctx.moveTo(cx + px, cy + pz);
        ctx.lineTo(cx + px + dirX, cy + pz + dirZ);
        ctx.stroke();
    }

    function triggerGameOver() {
        gameOver = true;
        document.getElementById('finalScore').textContent = score;
        document.getElementById('finalPackages').textContent = packagesDelivered;
        document.getElementById('finalCombo').textContent = bestCombo + 'x';
        gameOverDiv.style.display = "block";
    }

    function restartGame() {
        location.reload();
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

})();
</script>

</body>
</html>
